var documenterSearchIndex = {"docs":
[{"location":"license/#MIT-License","page":"License","title":"MIT License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2024 arnaud-ma <84045859+arnaud-ma@users.noreply.github.com> and contributors","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"lib/private/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"lib/private/#Index","page":"Private API","title":"Index","text":"","category":"section"},{"location":"lib/private/","page":"Private API","title":"Private API","text":"Pages = [\"private.md\"]","category":"page"},{"location":"lib/private/#Documentation","page":"Private API","title":"Documentation","text":"","category":"section"},{"location":"lib/private/","page":"Private API","title":"Private API","text":"Modules = [GridSim]\nPublic = false\nOrder = [:function, :type]","category":"page"},{"location":"lib/private/#GridSim.firstday_with_nbterr-Union{Tuple{V}, Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}, Vector{V}}} where V","page":"Private API","title":"GridSim.firstday_with_nbterr","text":"firstday_with_nbterr(grid_size::Tuple{Int,Int}, territory_size::Tuple{Int,Int}, fill::Vector{V})\n\nSame as firstday but with the number of territories returned as well.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#GridSim.nb_territories-Tuple{Tuple{Int64, Int64}, Tuple{Int64, Int64}}","page":"Private API","title":"GridSim.nb_territories","text":"nb_territories(grid_size::Tuple{Int,Int}, terr_size::Tuple{Int,Int})\n\nReturn the number of territories in the grid for each axis.\n\n\n\n\n\n","category":"method"},{"location":"starting/#Getting-started","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"starting/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The GridSim package is not available in the Julia package registry, but you can install it using the repository URL.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"julia> ]add https://github.com/arnaud-ma/GridSim.jl.git","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The guide assumes that you have successfully installed the package.","category":"page"},{"location":"starting/#Basic-usage","page":"Getting Started","title":"Basic usage","text":"","category":"section"},{"location":"starting/#Creating-a-game","page":"Getting Started","title":"Creating a game","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"To create a game, you only need 3 informations:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"The initial grid of cells (a matrix)\nThe function that will determine the new value of a cell at each day\nA seed or a random number generator to generate the random values","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"For the initial grid, you can have any matrix of any type to the game. But we provide a helper function to create a grid with a specific pattern: firstday.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"julia> using GridSim\njulia> first_day = firstday((4, 4), (2, 2), Int)\n4×4 Matrix{Int64}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"For the function rule, it must take the following arguments in this order:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"::AbstractMatrix : the matrix of the day\n::Tuple{Int,Int} : the size of the grid (i.e. size(M))\n::Int : the row index of the cell\n::Int : the column index of the cell","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"However, we provide some predefined rules that you can use directly:","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"neigh_disk : Selects the neighbors of the value, edges are not linked\nneigh_cylinder : Selects the neighbors of the value, only bottom and top are linked\nneigh_torus : Selects the neighbors of the value, all edges are linked","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"For the random number generator, you can either pass a seed or a random number generator (like Random.MersenneTwister(seed)). If a seed is provided, the Random.Xoshiro(seed) generator will be used.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"julia> game = newgame(first_day, neigh_disk, rng=1)","category":"page"},{"location":"starting/#Running-the-game","page":"Getting Started","title":"Running the game","text":"","category":"section"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"You can now iterate over the game's days using the days function.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"julia> for day in days(game, 3)\n           println(day)\n       end\n[1 1 2 2; 1 3 2 2; 3 4 4 4; 3 3 4 4]\n[1 1 2 2; 1 3 2 2; 3 4 4 4; 3 3 4 4]\n[1 1 2 2; 1 3 2 2; 3 4 4 4; 3 3 4 4]","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"Since days(game, args...) is just a simple iterator, you can use any tools that work with iterators, like collect to save the results in a vector, IterTools.nth to get the nth element, etc.","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"Refer to the days function documentation for more details about the options you can pass to it (like when to stop the iteration, or not create a copy of the game at each day to improve performance).","category":"page"},{"location":"starting/","page":"Getting Started","title":"Getting Started","text":"And that's it! Check the next sections for an example of how to visualize / save the game in a file.","category":"page"},{"location":"lib/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Game-rules","page":"Public API","title":"Game rules","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"gamerules","category":"page"},{"location":"lib/public/#GridSim.gamerules","page":"Public API","title":"GridSim.gamerules","text":"gamerules(grid_size::Tuple{Int,Int}, cellfunc::Union{Function,Symbol,String}; rng=nothing)\n\nCreate a GameRules object, given the grid size, the cell function and an optional random number generator or seed.\n\nArguments\n\ngrid_size : the size of the grid\ncellfunc : the function that will be used to determine the next value of each cell.   It must take the following arguments in the same order :\n::AbstractMatrix : the matrix of the day\n::Tuple{Int,Int} : the size of the grid (i.e. size(M))\n::Int : the row index of the cell\n::Int : the column index of the cell\n\nKeywords (optional)\n\nrng::Union{AbstractRNG,Integer} : the random number generator to use. If passed a seed   (an integer), it will create the default julia algorithmic random number generator   (Xoshiro) with this seed. If not provided, it will generate a random seed.\n\nExample\n\njulia> function cellfunc(M, grid_size, i, j)\n           # Return the cell value and the value of the cell above\n           # (if it exists)\n           i == 1 && return [M[i, j]]\n           return [M[i, j], M[i-1, j]]\n       end\ncellfunc (generic function with 1 method)\n\njulia> gamerules((4, 4), cellfunc, rng=1)\nGridSim.GameRules((4, 4), cellfunc, Random.Xoshiro(0xfff0241072ddab67, 0xc53bc12f4c3f0b4e, 0x56d451780b2dd4ba, 0x50a4aa153d208dd8, 0x3649a58b3b63d5db), 1)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"This package already implements three rules:","category":"page"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"neigh_disk : Selects the neighbors of the value, edges are not linked\nneigh_cylinder : Selects the neighbors of the value, only bottom and top are linked\nneigh_torus : Selects the neighbors of the value, all edges are linked","category":"page"},{"location":"lib/public/#Game-creation","page":"Public API","title":"Game creation","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"newgame","category":"page"},{"location":"lib/public/#GridSim.newgame","page":"Public API","title":"GridSim.newgame","text":"newgame(first_day::AbstractMatrix, rules::GameRules)\nnewgame(first_day::AbstractMatrix, cellfunc::Function, fill::Type; rng=nothing)\nnewgame(grid_size::Tuple{Int,Int}, territory_size::Tuple{Int,Int}, cellfunc::Function, fill::Type; rng=nothing)\n\nCreate a Game object with the specified first day matrix and the rules. These two arguments can be automatically created with the firstday and gamerules functions, respectively. Or you can pass the arguments directly into the constructor. See the documentation of these two functions for more details.\n\nExample\n\njulia> game = newgame((4, 4), (2, 2), neigh_disk, Int, rng=1)\nGridSim.Game{Matrix{Int64}}([1 1 2 2; 1 1 2 2; 3 3 4 4; 3 3 4 4], GridSim.GameRules((4, 4), neigh_disk, Random.Xoshiro(0xfff0241072ddab67, 0xc53bc12f4c3f0b4e, 0x56d451780b2dd4ba, 0x50a4aa153d208dd8, 0x3649a58b3b63d5db), 1))\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Game-iteration","page":"Public API","title":"Game iteration","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"nextday!","category":"page"},{"location":"lib/public/#GridSim.nextday!","page":"Public API","title":"GridSim.nextday!","text":"nextday!(game, oldday, newday)\n\nCompute the next game day in the newday matrix (inplace), based on the oldday matrix that is the day just before.\n\nExample\n\njulia> game = newgame((4, 4), (2, 2), neigh_disk, Int, rng=1);\n\njulia> new_day = similar(firstday(game));\n\njulia> nextday!(game, firstday(game), new_day)\n\njulia> new_day\n4×4 Matrix{Int64}:\n 1  2  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"days","category":"page"},{"location":"lib/public/#GridSim.days","page":"Public API","title":"GridSim.days","text":"days(game::Game[,maxdays]; stop_check=1, copydays=true)\n\nReturn an iterator over the days of the game. By default, it is a secure iterator at the cost of performance (create a copy and check when to stop at each iteration).\n\nBe aware that the number of days can be less than maxdays because it will stop when detecting a \"stable\" game (i.e. when all the cells have the same value).\n\nArguments\n\ngame::Game : the game to iterate over\nmaxdays::Integer : the maximum number of days to iterate over. Set to nothing   to never stop, unless the game is stable and stop_check is not nothing.\n\nKeywords (optional)\n\nstop_check::Union{Integer, Nothing} : the number of days to wait before checking if the   game is stable. If the game is stable, the iterator will stop. Set to nothing to never check.\ncopydays : If false, the iterator will return the same matrix at each iteration,   modifying it inplace. DO NOT change it to false if you don't know exactly what you are doing.\n\nExample\n\njulia> game = newgame((4, 4), (2, 2), neigh_disk, Int, rng=1);\n\njulia> for day in days(game, 3)\n           println(day)\n       end\n[1 1 2 2; 1 1 2 2; 3 3 4 4; 3 3 4 4]\n[1 2 2 2; 1 1 2 2; 3 3 4 4; 3 3 4 4]\n[1 1 2 2; 1 2 4 4; 1 2 3 4; 3 4 4 4]\n\n\n\n\n\n","category":"function"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"endless_days","category":"page"},{"location":"lib/public/#GridSim.endless_days","page":"Public API","title":"GridSim.endless_days","text":"endless_days(game::Game)\n\nAlias for days(game, stop_check=nothing, copydays=false), that is an iterator that will never stop iterating over the game days.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Accessors","page":"Public API","title":"Accessors","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"You can access some properties of the game, for both game and iterator objects.","category":"page"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"firstday\nrules\nseedof\ngame_rng\ngridsize\ngrid_indexes","category":"page"},{"location":"lib/public/#GridSim.firstday","page":"Public API","title":"GridSim.firstday","text":"firstday(grid_size::Tuple{Int,Int}, territory_size::Tuple{Int,Int}, fill::Vector)\nfirstday(grid_size::Tuple{Int,Int}, territory_size::Tuple{Int,Int}, fill::Type)\nfirstday(game::Game)\n\nReturn the first day matrix of the game, based on the grid size, the territory size and a vector of values to fill the territories.\n\nThe fill argument can also be a type value but only few ones are supported :\n\n<:Real: Fill the territories with the values 1, 2, 3, ... of the correct type.\nRGB: Fill the territories with distinguishable colors.\n\nExample\n\njulia> firstday((4, 4), (2, 2), Int)\n4×4 Matrix{Int64}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> firstday((4, 4), (2, 2), Int8) # to save memory\n4×4 Matrix{Int8}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\njulia> firstday((4, 4), (2, 2), [\"hello\", \"world\"])\nERROR: ArgumentError: The length of the fill vector must be greater than the number of territories.\nNumber of territories : 4\n\njulia> firstday((4, 4), (2, 2), [\"hello\", \"world\", \"foo\", \"bar\"])\n4×4 Matrix{String}:\n \"hello\"  \"hello\"  \"world\"  \"world\"\n \"hello\"  \"hello\"  \"world\"  \"world\"\n \"foo\"    \"foo\"    \"bar\"    \"bar\"\n \"foo\"    \"foo\"    \"bar\"    \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.rules","page":"Public API","title":"GridSim.rules","text":"rules(game::Game)\nrules(iter::DaysIterator)\n\nReturn the GameRules object of the game or the iterator.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.seedof","page":"Public API","title":"GridSim.seedof","text":"seedof(game::Game)\nseedof(iter::DaysIterator)\n\nReturn the seed of the game or the iterator. If the game or the iterator was created with a random number generator (and not a seed), nothing will be returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.game_rng","page":"Public API","title":"GridSim.game_rng","text":"game_rng(game::Game)\ngame_rng(iter::DaysIterator)\n\nReturn the random number generator of the game or the iterator.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.gridsize","page":"Public API","title":"GridSim.gridsize","text":"gridsize(game::Game)\ngridsize(iter::DaysIterator)\n\nReturn the grid size of the game or the iterator as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.grid_indexes","page":"Public API","title":"GridSim.grid_indexes","text":"grid_indexes(game::Game)\ngrid_indexes(iter::DaysIterator)\n\nReturn the grid_indexes of the game or the iterator.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Visualization","page":"Public API","title":"Visualization","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Here is some utilities to modify the esthetic of the game grids.","category":"page"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"enlarge\nenlarge!","category":"page"},{"location":"lib/public/#GridSim.enlarge","page":"Public API","title":"GridSim.enlarge","text":"enlarge(M::AbstractMatrix)\n\nEnlarge a matrix by a factor λ. Each element of the matrix is repeated λ times in each direction. If M is a n×m matrix, the result will be a nλ×mλ matrix.\n\nExample\n\njulia> M = [1 2; 3 4]\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> enlarge(M, 2)\n4×4 Matrix{Int64}:\n 1  1  2  2\n 1  1  2  2\n 3  3  4  4\n 3  3  4  4\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.enlarge!","page":"Public API","title":"GridSim.enlarge!","text":"enlarge!(M::AbstractMatrix, container::AbstractMatrix, λ::Int)\n\nInplace version of enlarge. The result is stored in container. The container must be initialized with the correct size (nλ×mλ).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Stats-utilities","page":"Public API","title":"Stats utilities","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"count_values\nmost_common\nmost_commons","category":"page"},{"location":"lib/public/#GridSim.count_values","page":"Public API","title":"GridSim.count_values","text":"GridSim.count_values(array::AbstractArray{T}) -> Dict{T, Int}\n\nReturn a dictionary with the number of occurences of each value in the array. Elements of the array must be hashable.\n\nExample\n\njulia> GridSim.count_values([1, 2, 3, 2])\nDict{Int64, Int64} with 3 entries:\n  2 => 2\n  3 => 1\n  1 => 1\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.most_common","page":"Public API","title":"GridSim.most_common","text":"GridSim.most_common(array::AbstractArray{T}) -> T\n\nReturn the most frequent value in the array. If there are multiple values with the maximum number of occurences, the first one is returned.\n\nExample\n\njulia> GridSim.most_common([1, 2, 3, 2])\n2\njulia> GridSim.most_common([1, 2, 3, 2, 1])\n1\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#GridSim.most_commons","page":"Public API","title":"GridSim.most_commons","text":"GridSim.most_commons(array::AbstractArray) -> Vector\n\nReturn the most frequent value in the array. Faster than the same function from the StatsBase package.\n\nExample\n\njulia> GridSim.most_commons([1, 2, 3, 2, 1])\n2-element Vector{Int64}:\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GridSim","category":"page"},{"location":"#GridSim","page":"Home","title":"GridSim","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The GridSim package is a simple package to simulate a random grid-based game.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is a very flexible package, you just have to pass it an initial grid and a rule (via newgame), then you can iterate over the simulation (via days) and do whatever you want with this iteration.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See starting for more information on how to start using the package, and example for a complete example.","category":"page"},{"location":"example/#Example","page":"Example","title":"Example","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"CurrentModule = GridSim","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Let's create a game with this 3 informations:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using GridSim\nusing Colors: RGB\nrule = neigh_disk\nseed = 1\nfirst_day = firstday((60, 60), (20, 20), RGB)\ngame = newgame(first_day, rule, rng=seed)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now the first day looks like this:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"(Image: image)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We can now iterate over the game's days using the days function. For example, to visualize the first 30 days in live:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using Plots\n\nfor day in days(game, 30, copydays=false)\n    sleep(0.1)\n    display(plot(day, ticks=false, border=:none))\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note that we used copydays=false to avoid copying the days at each iteration. This can be done only because we don't need to keep the previous days in memory. If you want to get avery days, you can just do collect(days(game, 30)).","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Now we want to save the game in a video file","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using VideoIO\nusing ProgressMeter\n\n# weird bug with the default format, so we need to specify it\nopen_video(args...) = open_video_out(args..., target_pix_fmt=VideoIO.AV_PIX_FMT_YUV420P)\n\nall_days = collect(days(game)) # collect all the days (until there is only one color)\nfirst_frame = enlarge(firstday(game), 18)\nopen_video(name=\"game.mp4\", first_frame, framerate=10) do writer\n    @showprogress for frame in framestack\n        write_frame(video, enlarge(frame, 18))\n    end\nend","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"It will take some time to generate the video, but you should have a file named game.mp4 that looks like this https://www.youtube.com/watch?v=aSCUlpiplb0.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Note that we used GridSim.enlarge to make the video bigger and have a better resolution.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"We can also make a graph of the number of colors over time:","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"using StatsBase: countmap\ncounts = countmap.(all_days)\ny = [[get(count_day, i, 0) for count_day in counts] for i in keys(counts[1])]\nplot(y, xlabel=\"Day\", ylabel=\"Number of cells\", legend=false)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"And lots of other things, just use the days function to iterate or collect the days and then do whatever you want with them.","category":"page"}]
}
